// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: metrics.sql

package sqlc

import (
	"context"
	"database/sql"
)

const get_Brand_Key_Metrics = `-- name: Get_Brand_Key_Metrics :one
WITH campaign_data AS (
    SELECT 
        COUNT(*) AS total_campaigns
    FROM campaigns
    WHERE campaigns.brand_id = $1
),
active_influencers_data AS (
    SELECT 
        COUNT(DISTINCT a.id) AS active_influencers
    FROM affiliates a
    JOIN tracking_links tl ON a.id = tl.affiliate_id
    JOIN campaigns c ON tl.campaign_id = c.id
    JOIN clicks cl ON tl.id = cl.tracking_link_id
    WHERE c.brand_id = $1
    AND cl.timestamp >= NOW() - INTERVAL '30 days'
),
click_data AS (
    SELECT 
        COUNT(*) AS total_reach
    FROM clicks cl
    JOIN tracking_links tl ON cl.tracking_link_id = tl.id
    JOIN campaigns c ON tl.campaign_id = c.id
    WHERE c.brand_id = $1
),
conversion_data AS (
    SELECT 
        COALESCE(SUM(conv.amount * conv.weight), 0)::numeric(10, 2) AS total_revenue,
        COALESCE((COUNT(DISTINCT conv.id) * 100.0 / NULLIF(COUNT(cl.id), 0)), 0)::numeric(10, 1) AS conversion_rate,
        COALESCE((SUM(conv.amount * conv.weight) / NULLIF(COUNT(DISTINCT conv.id), 0)), 0)::numeric(10, 2) AS average_order_value
    FROM clicks cl
    JOIN tracking_links tl ON cl.tracking_link_id = tl.id
    JOIN campaigns c ON tl.campaign_id = c.id
    LEFT JOIN conversions conv ON cl.click_id = conv.click_id
    WHERE c.brand_id = $1
)
SELECT 
    campaign_data.total_campaigns,
    active_influencers_data.active_influencers,
    click_data.total_reach,
    conversion_data.total_revenue,
    conversion_data.conversion_rate,
    conversion_data.average_order_value
FROM campaign_data, active_influencers_data, click_data, conversion_data
`

type Get_Brand_Key_MetricsRow struct {
	TotalCampaigns    int64
	ActiveInfluencers int64
	TotalReach        int64
	TotalRevenue      string
	ConversionRate    string
	AverageOrderValue string
}

func (q *Queries) Get_Brand_Key_Metrics(ctx context.Context, brandID sql.NullInt64) (Get_Brand_Key_MetricsRow, error) {
	row := q.db.QueryRowContext(ctx, get_Brand_Key_Metrics, brandID)
	var i Get_Brand_Key_MetricsRow
	err := row.Scan(
		&i.TotalCampaigns,
		&i.ActiveInfluencers,
		&i.TotalReach,
		&i.TotalRevenue,
		&i.ConversionRate,
		&i.AverageOrderValue,
	)
	return i, err
}

const get_Campaign_Performance = `-- name: Get_Campaign_Performance :many
SELECT 
    TO_CHAR(cl.timestamp, 'Mon') AS month,
    COUNT(cl.id) AS impressions, -- Total clicks as a proxy for impressions
    COUNT(cl.id) AS clicks,     -- Total clicks
    COUNT(DISTINCT conv.id) AS conversions
FROM clicks cl
JOIN tracking_links tl ON cl.tracking_link_id = tl.id
JOIN campaigns c ON tl.campaign_id = c.id
LEFT JOIN conversions conv ON cl.click_id = conv.click_id
WHERE c.brand_id = $1
GROUP BY TO_CHAR(cl.timestamp, 'Mon')
ORDER BY MIN(cl.timestamp)
`

type Get_Campaign_PerformanceRow struct {
	Month       string
	Impressions int64
	Clicks      int64
	Conversions int64
}

func (q *Queries) Get_Campaign_Performance(ctx context.Context, brandID sql.NullInt64) ([]Get_Campaign_PerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, get_Campaign_Performance, brandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Get_Campaign_PerformanceRow
	for rows.Next() {
		var i Get_Campaign_PerformanceRow
		if err := rows.Scan(
			&i.Month,
			&i.Impressions,
			&i.Clicks,
			&i.Conversions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get_Revenue_Data = `-- name: Get_Revenue_Data :many
SELECT 
    TO_CHAR(s.timestamp, 'Mon') AS month,
    COALESCE(SUM(s.amount), 0)::numeric(10, 2) AS raw_revenue,
    STRING_AGG(DISTINCT s.currency, ', ') AS currencies -- Track currencies for logging
FROM sales s
WHERE s.brand_id = $1
GROUP BY TO_CHAR(s.timestamp, 'Mon')
ORDER BY MIN(s.timestamp)
`

type Get_Revenue_DataRow struct {
	Month      string
	RawRevenue string
	Currencies []byte
}

func (q *Queries) Get_Revenue_Data(ctx context.Context, brandID int64) ([]Get_Revenue_DataRow, error) {
	rows, err := q.db.QueryContext(ctx, get_Revenue_Data, brandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Get_Revenue_DataRow
	for rows.Next() {
		var i Get_Revenue_DataRow
		if err := rows.Scan(&i.Month, &i.RawRevenue, &i.Currencies); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
