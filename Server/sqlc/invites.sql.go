// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: invites.sql

package sqlc

import (
	"context"
	"database/sql"
)

const check_Invite = `-- name: Check_Invite :one
SELECT EXISTS (
    SELECT 1
    FROM invites
    WHERE campaign_id = $1 
    AND user_id = $2 
    AND status IN ('pending', 'accepted')
) AS exists
`

type Check_InviteParams struct {
	CampaignID int64
	UserID     int64
}

func (q *Queries) Check_Invite(ctx context.Context, arg Check_InviteParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, check_Invite, arg.CampaignID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const create_Invite = `-- name: Create_Invite :one
INSERT INTO invites (
    campaign_id,
    user_id,
    status,
    invited_at
) VALUES (
    $1, $2, 'pending', CURRENT_TIMESTAMP
) RETURNING id, campaign_id, user_id, status, invited_at, responded_at
`

type Create_InviteParams struct {
	CampaignID int64
	UserID     int64
}

func (q *Queries) Create_Invite(ctx context.Context, arg Create_InviteParams) (Invite, error) {
	row := q.db.QueryRowContext(ctx, create_Invite, arg.CampaignID, arg.UserID)
	var i Invite
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.UserID,
		&i.Status,
		&i.InvitedAt,
		&i.RespondedAt,
	)
	return i, err
}

const delete_Invite_By_ID = `-- name: Delete_Invite_By_ID :exec
DELETE FROM invites
WHERE id = $1
`

func (q *Queries) Delete_Invite_By_ID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, delete_Invite_By_ID, id)
	return err
}

const get_Invite_By_ID = `-- name: Get_Invite_By_ID :one
SELECT id, campaign_id, user_id, status, invited_at, responded_at
FROM invites
WHERE id = $1
`

func (q *Queries) Get_Invite_By_ID(ctx context.Context, id int64) (Invite, error) {
	row := q.db.QueryRowContext(ctx, get_Invite_By_ID, id)
	var i Invite
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.UserID,
		&i.Status,
		&i.InvitedAt,
		&i.RespondedAt,
	)
	return i, err
}

const get_Pending_Invites_By_UserID = `-- name: Get_Pending_Invites_By_UserID :many
SELECT 
    i.id,
    i.campaign_id,
    i.user_id,
    i.status,
    i.invited_at,
    i.responded_at,
    c.name AS campaign_name,
    c.description AS campaign_description,
    c.commission_rate,
    c.landing_url,
    c.created_at AS campaign_created_at,
    b.id AS brand_id,
    b.company_name,
    b.website,
    b.created_at AS brand_created_at
FROM invites i
JOIN campaigns c ON i.campaign_id = c.id
JOIN brands b ON c.brand_id = b.id
WHERE i.user_id = $1 AND i.status = 'pending'
ORDER BY i.invited_at DESC
`

type Get_Pending_Invites_By_UserIDRow struct {
	ID                  int64
	CampaignID          int64
	UserID              int64
	Status              string
	InvitedAt           sql.NullTime
	RespondedAt         sql.NullTime
	CampaignName        string
	CampaignDescription sql.NullString
	CommissionRate      string
	LandingUrl          string
	CampaignCreatedAt   sql.NullTime
	BrandID             int64
	CompanyName         string
	Website             sql.NullString
	BrandCreatedAt      sql.NullTime
}

func (q *Queries) Get_Pending_Invites_By_UserID(ctx context.Context, userID int64) ([]Get_Pending_Invites_By_UserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, get_Pending_Invites_By_UserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Get_Pending_Invites_By_UserIDRow
	for rows.Next() {
		var i Get_Pending_Invites_By_UserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.UserID,
			&i.Status,
			&i.InvitedAt,
			&i.RespondedAt,
			&i.CampaignName,
			&i.CampaignDescription,
			&i.CommissionRate,
			&i.LandingUrl,
			&i.CampaignCreatedAt,
			&i.BrandID,
			&i.CompanyName,
			&i.Website,
			&i.BrandCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
